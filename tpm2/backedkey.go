package tpm2

import (
	"bytes"
	"crypto/ecdsa"
	"crypto/sha256"
	"encoding/asn1"
	"fmt"
	"math/big"

	"github.com/IPA-CyberLab/h132/mytestdata"
	"github.com/google/go-tpm/tpm2"
	"github.com/google/go-tpm/tpm2/transport"
)

type BackedP256KeyConfig struct {
	KeyHandle tpm2.TPMHandle
	Password  []byte
}

type BackedP256Key struct {
	cfg BackedP256KeyConfig
	t   transport.TPM

	name   tpm2.TPM2BName
	public *ecdsa.PublicKey
}

func ProvisionBackedP256Key(cfg BackedP256KeyConfig, t transport.TPM) (*BackedP256Key, error) {
	k := &BackedP256Key{
		cfg: cfg,
		t:   t,
	}

	transientSrkHandle, err := LoadH132StorageRootKey(k.t)
	if err != nil {
		return nil, err
	}
	defer func() {
		_, _ = tpm2.FlushContext{FlushHandle: transientSrkHandle.Handle}.Execute(k.t)
	}()

	cl := tpm2.CreateLoaded{
		ParentHandle: transientSrkHandle,
		InPublic: tpm2.New2BTemplate(&tpm2.TPMTPublic{
			Type:    tpm2.TPMAlgECC,
			NameAlg: tpm2.TPMAlgSHA256, // Algorithm used to compute the name of the object
			ObjectAttributes: tpm2.TPMAObject{
				// [1] When SET, the object cannot be duplicated for use on a different TPM, either directly or indirectly and the Qualified Name of the object cannot change.
				FixedTPM: true,
				// [1] Should be SET when `FixedTPM` is SET.
				FixedParent: true,
				// [1] This attribute is SET for any key that was generated by TPM in TPM2_Create() or TPM2_CreatePrimary().
				SensitiveDataOrigin: true,
				// [1] authorization for operations that require USER role authorization may be given
				UserWithAuth: true,
				// This doesn't seem to be needed for ECDH (SLB9670 fails with TPM_RC_SCHEME if this is set)
				Decrypt: true,
				// The key is used for signing the h132 envelope.
				SignEncrypt: true,
			},
			Parameters: tpm2.NewTPMUPublicParms(tpm2.TPMAlgECC, &tpm2.TPMSECCParms{
				CurveID: tpm2.TPMECCNistP256,
				// Specify a null scheme so that the key can be used for both signing and ECDH.
				Scheme: tpm2.TPMTECCScheme{
					Scheme: tpm2.TPMAlgNull,
				},
			}),
		}),
		InSensitive: tpm2.TPM2BSensitiveCreate{
			Sensitive: &tpm2.TPMSSensitiveCreate{
				UserAuth: tpm2.TPM2BAuth{Buffer: cfg.Password},
			},
		},
	}
	// [1] https://trustedcomputinggroup.org/wp-content/uploads/TPM-Rev-2.0-Part-2-Structures-01.38.pdf

	// FIXME: read more of
	// https://trustedcomputinggroup.org/wp-content/uploads/TPM-2.0-1.83-Part-3-Commands.pdf
	clresp, err := cl.Execute(k.t)
	if err != nil {
		return nil, fmt.Errorf("CreateLoaded(P256Key): %w", err)
	}

	ec := tpm2.EvictControl{
		Auth: tpm2.TPMRHOwner,
		ObjectHandle: &tpm2.NamedHandle{
			Handle: clresp.ObjectHandle,
			Name:   clresp.Name,
		},
		PersistentHandle: k.cfg.KeyHandle,
	}
	if _, err := ec.Execute(k.t); err != nil {
		_, _ = tpm2.FlushContext{FlushHandle: clresp.ObjectHandle}.Execute(k.t)

		return nil, fmt.Errorf("EvictControl(P256Key): %w", err)
	}

	if err := k.readPublic(); err != nil {
		return nil, err
	}
	if err := k.smokeTest(); err != nil {
		return nil, fmt.Errorf("smokeTest failed: %w", err)
	}

	return k, nil
}

func LoadBackedP256Key(cfg BackedP256KeyConfig, t transport.TPM) (*BackedP256Key, error) {
	k := &BackedP256Key{
		cfg: cfg,
		t:   t,
	}
	if err := k.readPublic(); err != nil {
		return nil, err
	}
	if err := k.smokeTest(); err != nil {
		return nil, fmt.Errorf("smokeTest failed: %w", err)
	}

	return k, nil
}

const HandleErr = tpm2.TPMRCHandle

// ReadPublic reads the public part of the key from the TPM.
func ReadPublic(tpm transport.TPM, handle tpm2.TPMHandle) (tpm2.TPM2BName, *ecdsa.PublicKey, error) {
	rp := tpm2.ReadPublic{ObjectHandle: handle}
	rpresp, err := rp.Execute(tpm)
	if err != nil {
		return tpm2.TPM2BName{}, nil, fmt.Errorf("ReadPublic(P256Key): %w", err)
	}

	name := rpresp.Name

	pc, err := rpresp.OutPublic.Contents()
	if err != nil {
		return name, nil, fmt.Errorf("ReadPublic(P256Key).OutPublic.Contents(): %w", err)
	}
	if pc.Type != tpm2.TPMAlgECC {
		return name, nil, fmt.Errorf("ReadPublic(P256Key): not an ECC key")
	}
	ecd, err := pc.Parameters.ECCDetail()
	if err != nil {
		return name, nil, fmt.Errorf("ReadPublic(P256Key).Parameters.ECCDetail(): %w", err)
	}
	c, err := ecd.CurveID.Curve()
	if err != nil {
		return name, nil, fmt.Errorf("ReadPublic(P256Key).CurveID.Curve(): %w", err)
	}
	u, err := pc.Unique.ECC()
	if err != nil {
		return name, nil, fmt.Errorf("ReadPublic(P256Key).Unique.ECC(): %w", err)
	}

	return name, &ecdsa.PublicKey{
		Curve: c,
		X:     new(big.Int).SetBytes(u.X.Buffer),
		Y:     new(big.Int).SetBytes(u.Y.Buffer),
	}, nil
}

// readPublic reads the public key part from the TPM.
func (k *BackedP256Key) readPublic() error {
	name, pub, err := ReadPublic(k.t, k.cfg.KeyHandle)
	if err != nil {
		return err
	}

	k.name = name
	k.public = pub
	return nil
}

func (k *BackedP256Key) Public() *ecdsa.PublicKey {
	return k.public
}

func (k *BackedP256Key) Sign(s256digest []byte) ([]byte, error) {
	if len(s256digest) != 32 {
		return nil, fmt.Errorf("Sign(P256Key): invalid digest length")
	}

	signresp, err := tpm2.Sign{
		KeyHandle: tpm2.AuthHandle{
			Handle: k.cfg.KeyHandle,
			Name:   k.name,
			Auth:   tpm2.PasswordAuth(k.cfg.Password),
		},
		Digest: tpm2.TPM2BDigest{Buffer: s256digest},
		InScheme: tpm2.TPMTSigScheme{
			Scheme: tpm2.TPMAlgECDSA,
			Details: tpm2.NewTPMUSigScheme(tpm2.TPMAlgECDSA, &tpm2.TPMSSchemeHash{
				HashAlg: tpm2.TPMAlgSHA256,
			}),
		},
		// Simply verify the data being signed is a hash
		Validation: tpm2.TPMTTKHashCheck{
			Tag: tpm2.TPMSTHashCheck,
		},
	}.Execute(k.t)
	if err != nil {
		return nil, fmt.Errorf("Sign(P256Key): %w", err)
	}

	raw, err := signresp.Signature.Signature.ECDSA()
	if err != nil {
		return nil, fmt.Errorf("Sign(P256Key).Signature.Signature.ECDSA(): %w", err)
	}

	r := big.NewInt(0).SetBytes(raw.SignatureR.Buffer)
	s := big.NewInt(0).SetBytes(raw.SignatureS.Buffer)

	return asn1.Marshal(struct{ R, S *big.Int }{r, s})
}

func (k *BackedP256Key) ECDH(pub *ecdsa.PublicKey) ([]byte, error) {
	ecdhresp, err := tpm2.ECDHZGen{
		KeyHandle: tpm2.AuthHandle{
			Handle: k.cfg.KeyHandle,
			Name:   k.name,
			Auth:   tpm2.PasswordAuth(k.cfg.Password),
		},
		InPoint: tpm2.New2B(tpm2.TPMSECCPoint{
			X: tpm2.TPM2BECCParameter{Buffer: pub.X.Bytes()},
			Y: tpm2.TPM2BECCParameter{Buffer: pub.Y.Bytes()},
		}),
	}.Execute(k.t)
	if err != nil {
		return nil, fmt.Errorf("ECDH(P256Key): %w", err)
	}

	contents, err := ecdhresp.OutPoint.Contents()
	if err != nil {
		return nil, fmt.Errorf("ECDH(P256Key).OutPoint.Contents(): %w", err)
	}

	return contents.X.Buffer, nil
}

var (
	smokeTestDigest = sha256.Sum256([]byte("smoketest"))
)

func (k *BackedP256Key) smokeTest() error {
	// Test `Sign()`
	sig, err := k.Sign(smokeTestDigest[:])
	if err != nil {
		return fmt.Errorf("Sign() failed: %w", err)
	}

	ok := ecdsa.VerifyASN1(k.public, smokeTestDigest[:], sig)
	if !ok {
		return fmt.Errorf("Signature verification failed")
	}

	// Test `ECDH()`
	priv1, err := mytestdata.Priv1.ECDH()
	if err != nil {
		return fmt.Errorf("test1.ECDH() failed: %w", err)
	}

	tpmpub, err := k.public.ECDH()
	if err != nil {
		return fmt.Errorf("k.Public.ECDH() failed: %w", err)
	}

	ss, err := priv1.ECDH(tpmpub)
	if err != nil {
		return fmt.Errorf("test1.priv.ECDH() failed: %w", err)
	}

	tpmss, err := k.ECDH(&mytestdata.Priv1.PublicKey)
	if err != nil {
		return fmt.Errorf("k.ECDH(test1.Public) failed: %w", err)
	}

	if !bytes.Equal(ss, tpmss) {
		return fmt.Errorf("ECDH sharedsecret mismatch")
	}

	return nil
}
